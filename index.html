<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Nested Volume Shader</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; height: 100%;
    background: black;
  }
  canvas {
    display: block; width: 100vw; height: 100vh;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script type="x-shader/x-vertex" id="vertexShader">
attribute vec4 a_position;
void main() {
  gl_Position = a_position;
}
</script>

<script type="x-shader/x-fragment" id="fragmentShader">
precision highp float;

uniform vec2 u_resolution;
uniform float u_time;

// Simple volume function to nest inside itself
float volumeKernel(vec3 p) {
    float b = length(p);
    float c = atan(p.y, p.x) * 8.0;
    float d = acos(p.z / b) * 8.0;
    float powB = pow(b, 8.0);
    vec3 a = vec3(
      powB * sin(d) * cos(c),
      powB * sin(d) * sin(c),
      powB * cos(d)
    ) + p;

    if (b > 6.0) {
      return 4.0 - dot(a, a);
    }
    return volumeKernel(a);  // recursive call — careful, GLSL doesn’t support recursion, so this is for concept only!
}

// Since GLSL doesn't allow recursion, we unroll it manually:
float nestedVolumeKernel(vec3 p) {
    vec3 a = p;
    float val = 0.0;
    for (int i = 0; i < 5; i++) {
        float b = length(a);
        float c = atan(a.y, a.x) * 8.0;
        float d = acos(a.z / b) * 8.0;
        float powB = pow(b, 8.0);
        a = vec3(
            powB * sin(d) * cos(c),
            powB * sin(d) * sin(c),
            powB * cos(d)
        ) + p;
        if (b > 6.0) break;
        val = 4.0 - dot(a, a);
    }
    return val;
}

// Main render function
void main() {
    vec2 uv = (gl_FragCoord.xy / u_resolution.xy) * 2.0 - 1.0;
    uv.x *= u_resolution.x / u_resolution.y;

    // Animate the position over time
    vec3 pos = vec3(uv * 0.5, sin(u_time) * 0.5);

    // Apply nested volume kernel multiple times for deep nesting
    vec3 p = pos;
    float v1 = nestedVolumeKernel(p);
    float v2 = nestedVolumeKernel(vec3(v1));
    float v3 = nestedVolumeKernel(vec3(v2));
    float v4 = nestedVolumeKernel(vec3(v3));
    float v5 = nestedVolumeKernel(vec3(v4));

    float val = v5;

    // Color mapping
    vec3 color = vec3(0.5 + 0.5 * sin(val * 10.0 + u_time),
                      0.5 + 0.5 * cos(val * 5.0 + u_time * 0.5),
                      0.5 + 0.5 * sin(val * 3.0 + u_time * 0.3));

    gl_FragColor = vec4(color, 1.0);
}
</script>

<script>
(function(){
  const canvas = document.getElementById("glcanvas");
  const gl = canvas.getContext("webgl");

  if (!gl) {
    alert("WebGL not supported");
    return;
  }

  // Resize canvas to fill window
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  window.addEventListener("resize", resize);
  resize();

  // Compile shader helper
  function compileShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error("Shader compile failed: ", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  // Create program helper
  function createProgram(vsSource, fsSource) {
    const vertexShader = compileShader(gl.VERTEX_SHADER, vsSource);
    const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fsSource);
    if (!vertexShader || !fragmentShader) return null;

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error("Program link failed: ", gl.getProgramInfoLog(program));
      return null;
    }
    return program;
  }

  const vsSource = document.getElementById("vertexShader").textContent;
  const fsSource = document.getElementById("fragmentShader").textContent;

  const program = createProgram(vsSource, fsSource);
  gl.useProgram(program);

  // Create a fullscreen quad
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([
      -1, -1,
      1, -1,
      -1, 1,
      -1, 1,
      1, -1,
      1, 1,
    ]),
    gl.STATIC_DRAW
  );

  const positionLoc = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

  // Uniform locations
  const resolutionLoc = gl.getUniformLocation(program, "u_resolution");
  const timeLoc = gl.getUniformLocation(program, "u_time");

  // Render loop
  let startTime = Date.now();

  function render() {
    gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
    gl.uniform1f(timeLoc, (Date.now() - startTime) * 0.001);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
  }

  render();

})();
</script>

</body>
</html>
